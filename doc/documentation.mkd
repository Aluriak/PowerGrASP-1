# PowerGrASP
This documentation is dedicated to PowerGrASP users who want to know more and contributors,
while the README is sufficient to understand how PowerGrASP works, and how perform a compression.
Moreover, an heavy use of internal docstring have been performed: doc inside the code is the most up-to-date ressource about PowerGrASP functionnalities, behavior and usage.
Don't forget that Python allows an access to the docstring without browsing the code with the help(1) function.

PowerGrASP is a Python module that allows user to compress a graph, according to the Power Graph method,
and as final output produce a file that contains the compressed graph (see *output* and *visualization* for details).
The compression, performed with the help of Formal Concept Analysis and Logic Programming,
have a visualization interest: the compressed graph is easier to read, even in case of big graphs, and,
in the case of biological data, have some interesting properties for data interpretation.

Some references are given at the end.


## Architecture
PowerGrASP mainly uses CPython and Clingo, an Answer Set Programming implementation by *Potassco*.
All is packaged in a pythonic way for allows the upload on pypi. One of the main dependance is [pyasp](http://github.com/sthiele/pyasp),
the module making the bridge between ASP and Python.
With the help of the [docopt](http://docopt.org) module, PowerGrASP can be interfaced with the command-line as with another Python program.
The [matplotlib](http://matplotlib.org/) and [pandas](http://pandas.pydata.org/) modules are used for compression statistics plotting (see *plotting*).

The program us basically a Python code that call Clingo multiple times, while the input graph has a compressible motif,
and finally perform a traduction of the concepts (biclique, clique, star) in the output format.

This output format, named bubble, is notabily readable by Cytoscape, once the plugin [CyOog](http://www.biotec.tu-dresden.de/research/schroeder/powergraphs/download-cytoscape-plugin.html) is installed.


### Modules
The followings modules compose the important parts in the PowerGrASP source code.

- *\__main__*: interface between the command line and the compression procedures.
- *atoms*: provides many functions for manipulating atoms objects, output of ASP solvers.
- *commons*: global definitions of constants, various generalist functions and logging management.
- *compression*: implementation of the compression algorithm.
- *converter*: converter library, that allows the transformation of input and output data in treatable formats.
- *graph_reduction*: implementation of a graph reduction algorithm (see optimizations).
- *info*: informations on the package itself.
- *observers*: implementations of various compression observers, with different roles.
- *plotting*: routines for plotting the statistics data.
- *powergrasp*: main API, a wrapper around the compression routines.
- *solving*: provides functions abstracting solving treatment like solver construction and best solution access.
- *statistics*: defines way to do compression statistics, and how print/stock them.
- *test*: unit test subpackage.
- *tests*: repository of biological and non-biological data, used for testing and demonstration on compression.
- *utils*: definition of functions that have been used one time ; not important, but can be useful for generate data.

Moreover, inside the PowerGrASP module is a *ASPSources* subdirectory,
that contains all ASP source code used by PowerGrASP.


## Algorithm
While the more important part of the compression is performed in the ASP side, the compression algorithm can't be detailed
without description of Clingo heuristics and behavior. This is not the goal of this document.
Altough some tips on the implementation will be described below.

### Python side
It needs to be well understood.

1. determination of the connected component (ASP solver used (*extraction.lp*)).
2. for each connected component:
    2. search for the best clique (ASP solver used) (ASP solver used (*findbestclique.lp* and *postprocessing.lp*)).
    3. search for the best biclique, that must be better than the clique (ASP solver used (*findbestbiclique.lp* and *postprocessing.lp*)).
    4. if a model is found (either clique or biclique):
        2. save the constructed powernodes and poweredges.
        3. call statistics for take count of advancement.
        4. rebranch to 2.1, with the step number increased by 1.
    5. else: (no interesting model)
        1. break the compression for this connected component.
        2. produce the output format string and write it in output file (ASP solver used (*inclusions.lp*)).
3. print final statistics.

Note that at each iteration, grounding and solving is performed three times.


### Scoring
The score of generated concepts (clique, biclique, star) are equals to the number of edge it covered.
At each step, the best concept, choosen for being produced, is one of the concept with the higher edge cover.

NB: in the *postprocessing.lp* ASP source, the score is inverted for being minimized by the solver.
The main reason is because the solver deals best with minimization than maximization.


### Blocks and alternatives
With blocks, PowerGrASP avoid creation of overlapping power nodes.
A block is a partition of the space, and a node can only be in a single block.
By their nature, blocks and power nodes are really close. Power nodes keep reference to all their contained nodes, while blocks just keep the nodes that are contained directly.
An inclusion tree of blocks is maintained along the compression.
This appears to be very costly, probably because of the maximality constraint that can't be used with blocks:
we can't discard models that are not maximal, because the maximal model is possibly in an overlapping condition
with a previously created power node.

This costly treatment of the data is mainly used and maintained in the *postprocessing.lp* ASP source,
and a significant amount of time have been dedicated to find a best way to avoid overlapping power nodes.

Currently, the best concurrent of blocks is the *concept post-reduction*:
instead of keep all concepts, and scores them after discard those that overlaps,
it is possible to generate only the maximum ones, and reduce them until they overlaps,
and finally score the reduced ones.
This principle, implemented in the branch *enhancement#15*, seems to be slower. (2.4 times the time needed for the *structural binding* test case with blocks)




## Implementation details

### Converter

### Observer

### Logging

### Optimizations
The following parts are about the various optimizations implemented.


#### Score bounds  (since 0.3.X)
The score bounds (inclusives) are computed before any concept search, as follow:
- the initial best score is the number of edges in the graph
- the initial minimal score is 2
- after successful clique search, the minimal score is set to the score of the clique
- if a better score is possible (score of the clique is lower than the maximal score), a biclique is searched
- the score of the best found concept is set as the best score for the next step.

Another part of the score bound is the determination of a minimal lowerbound. This is not interesting,
while the benchmarks shows a slower compression.
The minimal score is 2, or equals to the score of the clique found (if any) at the same step for any biclique search.


#### Reduction of equivalent nodes  (currently tested)
Nodes with exactly the same attributes (== linked to the same other nodes) are always handled together in cases of bicliques.
If N nodes have the same attributes, then the smaller lexicographically will be choosen as the normal node. The others are named «hidden» nodes.
The data extraction in *extract.lp* yields an equiv/2 atom, where equiv(X,Y) define Y as an hidden node, and X as a normal node.
In *findbestbiclique.lp* the equiv/2 atoms are used for define the content of each set of the biclique: if X is embed in a set, then all hidden nodes Y such as equiv(X,Y) will be added to the set.
The score can finally be computed.

However, cliques needs a special treatment. When a clique use a node X such as equiv(X,Y) exist, one hidden node Y is choosen and is no longer marked as hidden, as the equiv(X,Y) atom is not yielded by the postprocessing step.
The choosen Y node is put in the clique, and the node X score is decremented.


##### commits
preprocessing: a110480e4b0b3da00fdeb520239cf09b7aeb6c00  
postprocessing: 2faae7614d9eb8b0b9e943f542cb6ebc196a2214  
compression: 3dc32cc80664c4ae0c179b324726312ba2e125ae  
findbestclique: 403d7c7f18ff9724c0f0323b98b4c3fe19594b35  
clique test case: 2a8e21d2fede030fa4e5bf43f23f23ba2d236ee3  
main commit: 209d191f628fca4152893c9dc1aa1677205fa923  


### CLI & API
The CLI usage is described through the help:

    python -m powergrasp --help


The API is defined by the powergrasp module:

    import powergrasp
    help(powergrasp.compress)
    powergrasp.compress('graph.lp', 'output.bbl')

Cf *README.mkd* and *Makefile* for exact PowerGrASP command line or python usage.



## Visualization
PowerGrASP main goal is data visualization. There is some ways for perform that.

### Cytoscape
Print a power graph through Cytoscape is made possible by the [CyOog](http://www.biotec.tu-dresden.de/research/schroeder/powergraphs/) plugin,
which handle the endemic format *Bubble* developed by the BIOTEC team in 2012. (cf references)
Cytoscape, in order to using the CyOog plugin, must be in version __[2.x](http://www.cytoscape.org/download_old_versions.html)__.

This plugin is the result of their work on graph compression, and embeds BIOTEC compression program.
The bubble format describes the compressed graph, is close to the Nested Network Format (NNF), is human readable,
and can be loaded by CyOog for print the compressed graph.

PowerGrASP is only a bubble file generator: it works independantly of Cytoscape,
and use other technics for reach a comparable result with CyOog.
As a consequence, while showing the compressed graph is not PowerGrASP's job,
it lets Cytoscape (and CyOog) perform the final printings.

### Oog Command line tool
BIOTEC team also released a [command line tool](http://www.biotec.tu-dresden.de/research/schroeder/powergraphs/download-command-line-tool.html) for power graph analysis.
This tool allow to print a bubble file without Cytoscape usage, with something like:

    java -jar Oog.jar -inputfiles=path/to/bubble.bbl -img -f=png

Add *&>/dev/null* for prevent any logging output.
Some problems can appears, notabily the normal edges that are not displayed.


### DOT file format
A layout engine of graphviz named *fdp* starts to handle graph clusters.
According to this [demonstration](http://www.graphviz.org/content/fdpclust), clusters are exactly what the powernodes are.

This needs to be implemented, but it can be an interesting alternative to others visualization tools.


### Statistics about compression
Using the `--stats-file=filename` option, PowerGrASP will generate statistical data about the compression for each step, and store it in CSV format in given *filename*. With the `--plot-stats` flag, or the `--plot-file=plot.png` option, PowerGrASP will look for the data in *filename* and plot it using matplotlib.




## I/O formats
### Input
The only input format managed by the compression is an ASP code that contains atoms *edge/2*, describing the link between two nodes identified by their labels.
However, PowerGrASP embeds a converter library that works before PowerGrASP
for create a new file from the non-ASP input file.
Formats currently managed by PowerGrASP are described in the internal docstring and in the README.

### Output
PowerGrASP only outputs *Bubble*-formated files. Bubble is a file format defined by BIOTEC, used by the module [CyOog](http://www.biotec.tu-dresden.de/research/schroeder/powergraphs/download-cytoscape-plugin.html) of [Cytoscape **2**](http://www.cytoscape.org/download_old_versions.html).
The converter library embedded in PowerGrASP can perform conversion after the compression.
This is, however, not an important feature, while the only way for printing power graphs
is Cytoscape and the module CyOog, which use exclusively the Bubble format.
Like for inputs, managed output files are detailed in internal docstring and README.

As for inputs, PowerGrASP can be extended in order to provides new output formats.

### Extension
Both input and output formats can be easily added to the module.
For input formats, take a look to the following commits:

- core implementation: [1dbed399b89139a9ce9e8d2ae2cc686a9392e905](https://github.com/Aluriak/PowerGrASP/commit/1dbed399b89139a9ce9e8d2ae2cc686a9392e905)
- example integration: [c4c95a0964fc999aa0ac92f02fbbd648da638bcd](https://github.com/Aluriak/PowerGrASP/commit/c4c95a0964fc999aa0ac92f02fbbd648da638bcd)
- unit tests: [2699fd1ec9ba10f5ee8a2617be3269f85dbdcbea](https://github.com/Aluriak/PowerGrASP/commit/2699fd1ec9ba10f5ee8a2617be3269f85dbdcbea)

For output formats, the core implementation is equivalent, but currently unit tests and example integration are more difficult to test.




## References
The Power Graph approach for graph compression allows a lossless compression with an emphasis on biological meaning.
In fact, formal concepts used by Power Graph analysis have a sens in biology, especially in the case of proteomes.

All graphs can be compressed through Power Graph, and will be more readable once compressed,
but interactomes, at least, also gain in interpretability.

The main inspiration of PowerGrASP: PowerGraph Analysis:

    Loïc Royer, Matthias Reimann, Bill Andreopoulos, and Michael Schroeder.
    Unraveling Protein Networks with Power Graph Analysis.
    PLoS Comput Biol, 4(7):e1000108, July 2008.

Usage of the PowerGraph Analysis:

    Loic Royer, Matthias Reimann, A. Francis Stewart, and Michael Schroeder.
    Network Compression as a Quality Measure for Protein Interaction Networks.
    PLoS ONE, 7(6):e35729, June 2012.

    Yun Zhang, Charles A Phillips, Gary L Rogers, Erich J Baker, Elissa J Chesler, and Michael A Langston.
    On finding bicliques in bipartite graphs: a novel algorithm and
    its application to the integration of diverse biological data types.
    BMC Bioinformatics, 15(1):110, 2014.

ASP through Potassco implementation:

    M. Gebser, R. Kaminski, B. Kaufmann, M. Ostrowski, T. Schaub, and M. Schneider.
    Potassco: The Potsdam answer set solving collection.
    AI Communications, 24(2):107–124, 2011.
